---
title: "STAT 431 Project Report"
author: "German Bautista, Eric Bayer, Quentin Wetzel"
date: "12/15/2021"
output:
  html_document:
    toc: yes
    toc_float: yes
---

```{r, include = FALSE}
knitr::opts_chunk$set(echo = FALSE)
```

# Spotify Analysis

## Introduction





## Methods





## Results









Analysis





<!-- ## Discussion -->




<!-- ## Appendix -->

```{r, eval = FALSE}
# Load library
library(rjags)

# Read data 
data = read.table("ungrouped_spotify_data.txt")

# Make the streams per day variable. 
data$streams_day = data$stream / data$days

# This orders alphabetically by genre 
# This is vital for our bugs model to makes sense
data = data[order(data$top.genre), ]

#This resets the row numbers so again the bugs model works
rownames(data) = NULL

#This is just here since to show why I put the values I did in the bugs model variable ind
indicator = c(match(unique(data$top.genre), data$top.genre), length(data[,1])+1)

#The bug model is weird, but essentially I coded it so each genre has its own loop over it's songs. 
#Please check that it makes sense
#a and b needed priors in order for the model to work I think. 
# I'm not sure I got the priors/hyperpriors assigned correctly
# I got ride of N in our model since it doesn't really make sense for this model since
# our data doesn't really have "trials" per se


#Assign the thousands of streams per day to Y
d <- list(Y=data[,4])

#I set random priors for a and b. I think those are the only ones that need it.
# Feel free to change the numbers when testing
inits <- list(list(a=.0001, b=.0001), 
              list(a=1000, b=1000), 
              list(a=.0001, b=1000))

#Run the jags model
m <- jags.model("hierarchical4.bug", d, inits, n.chains=3)

### Make a preliminary run of 1000 iterations, with monitoring
#NOTE: don't do too many iterations or it will take forever to plot the graphs/exit the code

x <- coda.samples(m, c("theta", "lambda"), n.iter=1000)


### Assess convergence

plot(x, smooth=FALSE, ask=TRUE)

autocorr.plot(x[1], ask=TRUE)

gelman.diag(x, autoburnin=FALSE)

gelman.plot(x, autoburnin=FALSE, ask=TRUE)


### Check stats after burn-in
#For some reason this never has worked for me in any assignment

summary(window(x, 400))

# Verify: Time-series SE less than 1/20 of SD
#Window seems to not work properly

plot(window(x, 400), trace=FALSE, ask=TRUE)
```

```{r, eval = FALSE}
# hierarchical4.bug file used for HBM

data {
  n.genres = 7
  ind = c(1, 31, 36, 43, 68, 72, 90, 100)
}
model {
  for (i in 1:n.genres) {
    for (j in ind[i]:(ind[i + 1] - 1)) {
      Y[j] ~ dpois(lambda[j])
      lambda[j] ~ dexp(theta[i])
    }
    theta[i] ~ dgamma(a,b)
  }
  a ~ dexp(0.001)
  b ~ dexp(0.001)
}
```
