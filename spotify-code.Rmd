---
title: "STAT 431 Project Report"
author: "German Bautista, Eric Bayer, Quentin Wetzel"
date: "12/15/2021"
output:
  html_document:
    toc: yes
    toc_float: yes
---

# Spotify Analysis

## Introduction





## Methods





## Results

```{r, message = FALSE, echo = FALSE}
# Load library
library(rjags)
```

```{r, echo = FALSE}
# Read data 
data = read.table("ungrouped_spotify_data.txt")

# Make the streams per day variable. 
data$streams_day = data$stream / data$days

# This orders alphabetically by genre 
# This is vital for our bugs model to makes sense
data = data[order(data$top.genre), ]

# This resets the row numbers so again the bugs model works
rownames(data) = NULL

# Shows how the indices were selected to use in the bugs file
indicator = c(match(unique(data$top.genre), data$top.genre), length(data[,1])+1)
```

```{r, echo = FALSE, message = FALSE}
# Add thousands of streams per day to Y
d = list(Y = data[ , 4])

# Set arbitrary uninformative priors
# Feel free to change a, b for testing purposes
inits = list(list(a = .0001, b = .0001), 
              list(a = 1000, b = 1000), 
              list(a = .0001, b = 1000))

#Run the JAGS model
m = jags.model("hierarchical4.bug", d, inits, n.chains = 3)
```

```{r, echo = FALSE}
# In paper, only plot the theta graphs
z = coda.samples(m, c("theta"), n.iter = 1e5)
```

The trace and densities of $\lambda_{ij}$ were not plotted due to to there being 100 of them. They met all of the convergence requirements that $\theta_j$ did.

The trace and densities of $\theta_j$ for $j = 1, 2, ..., 7$ are plotted below. 

```{r, echo = FALSE}
### Assess convergence
plot(z, smooth = FALSE, ask = TRUE)
```

The autocorrelation plots of $\theta_j$ for $j = 1, 2, ..., 7$ are plotted below. 

```{r, echo = FALSE}
# Autocorrelation plots for theta_j
autocorr.plot(z[1], ask = TRUE)
```

The Gelman diagnsotics of $\theta_j$ for $j = 1, 2, ..., 7$ are plotted below. 

```{r, echo = FALSE}
# Gelman diagnostics
gelman.diag(z, autoburnin = FALSE)
```

The Gelman plots of $\theta_j$ for $j = 1, 2, ..., 7$ are plotted below. are below

```{r, echo = FALSE}
# Check shrink factor after burn-in
gelman.plot(z, autoburnin = FALSE, ask = TRUE)
```

Summary statistics of $\theta_j$ for $j = 1, 2, ..., 7$:

```{r, echo = FALSE}
# Check summary statistics and verify that Time-series SE are less than 1/20 of SD
summary(z)
```


## Discussion










## Contributions




## Appendix

```{r, eval = FALSE}
# Load library
library(rjags)

# Read data 
data = read.table("ungrouped_spotify_data.txt")

# Make the streams per day variable. 
data$streams_day = data$stream / data$days

# This orders alphabetically by genre 
# This is vital for our bugs model to makes sense
data = data[order(data$top.genre), ]

# This resets the row numbers so again the bugs model works
rownames(data) = NULL

# Shows how the indices were selected to use in the bugs file
indicator = c(match(unique(data$top.genre), data$top.genre), length(data[,1])+1)

# Add thousands of streams per day to Y
d = list(Y = data[ , 4])

# Set arbitrary uninformative priors
# Feel free to change a, b for testing purposes
inits = list(list(a = .0001, b = .0001), 
              list(a = 1000, b = 1000), 
              list(a = .0001, b = 1000))

#Run the JAGS model
m = jags.model("hierarchical4.bug", d, inits, n.chains=3)

# Includes lambda for convergence checking
x = coda.samples(m, c("theta", "lambda"), n.iter=1e5)

# In paper, only plot the theta graphs
z = coda.samples(m, c("theta"), n.iter = 1e5)

### Assess convergence

plot(x, smooth = FALSE, ask = TRUE)

autocorr.plot(x[1], ask = TRUE)

gelman.diag(x, autoburnin = FALSE)

gelman.plot(x, autoburnin = FALSE, ask = TRUE)

# Check statistics after burn-in
summary(x)

# Verify that Time-series SE less than 1/20 of SD
plot(x, trace=FALSE, ask=TRUE)
```

```{r, eval = FALSE}
# hierarchical4.bug file used for HBM

data {
  n.genres = 7
  ind = c(1, 31, 36, 43, 68, 72, 90, 100)
}
model {
  for (i in 1:n.genres) {
    for (j in ind[i]:(ind[i + 1] - 1)) {
      Y[j] ~ dpois(lambda[j])
      lambda[j] ~ dexp(theta[i])
    }
    theta[i] ~ dgamma(a,b)
  }
  a ~ dexp(0.001)
  b ~ dexp(0.001)
}
```
